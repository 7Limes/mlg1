// Implementation for pseudo-floating point numbers

include "math"
include "output"


fn set_float_scale(scale) {
    global __float_scale = scale
    global __float_scale_log10 = ilog(10, __float_scale)
}


fn float(whole, decimal) {
    return whole * __float_scale + decimal
}


fn fmul(a, b) {
    return a * b / __float_scale
}


fn fdiv(a, b) {
    return a * __float_scale / b
}


fn fsin(x) {
    let PI = 31415 * __float_scale / 10000
    let TWO_PI = 62831 * __float_scale / 10000

    // Normalize to [0, 2*pi]
    while x >= TWO_PI {
        x = x - TWO_PI
    }
    while x < 0 {
        x = x + TWO_PI
    }

    // Normalize to [-pi, pi]
    if x > PI {
        x = x - TWO_PI
    }

    let result = 0
    let term = x
    let x_squared = x * x / __float_scale

    for (let n = 0; n < 10; n=n+1) {
        result = result + term

        term = term * x_squared / __float_scale
        term = -term
        let denominator = (2 * n + 2) * (2 * n + 3)
        term = term / denominator

        if term == 0 {
            break
        }
    }

    return result
}


// Output functions

fn print_float(x) {
    let whole = x / __float_scale
    let decimal = x % __float_scale
    print_int(whole)
    putchar(46)  // Decimal point

    let decimal_log10 = ilog(10, decimal)
    let zero_padding = -decimal_log10 + __float_scale_log10 - 1
    for (let i = 0; i < zero_padding; i=i+1) {
        putchar(48)
    }
    print_int(decimal)
}


fn println_float(x) {
    print_float(x)
    putchar(10)
}
