include "math"


define _HYPHEN 45

define _FORMAT_CODE_PREFIX 37   // '%'
define _FORMAT_CODE_INT 105     // 'i'
define _FORMAT_CODE_STRING 115  // 's'


// Convert an integer to an ascii encoded string
fn int_to_str(buffer, x) {
    let amount_digits = x == 0
    let is_negative = x < 0
    x = abs(x)

    let x_copy = x
    while x_copy > 0 {
        x_copy = x_copy / 10
        amount_digits = amount_digits + 1
    }

    if is_negative {
        set(buffer, amount_digits+1)  // Set the length of the string
        buffer = buffer + 1
        set(buffer, 45)  // Set hyphen for negative
    }
    else {
        set(buffer, amount_digits)  // Set the length of the string
    }

    for (let i = buffer+amount_digits; i > buffer; i = i - 1) {
        let digit = x % 10 + 48
        x = x / 10
        set(i, digit)
    }
}


// Convert a string to an integer.
fn str_to_int(p_dest, string) {
    let string_length = get(string)
    if (string_length == 0) {
        return 1
    }

    // Error check for singular hyphen
    let first_char = get(string+1)
    if (string_length == 1) * (first_char == _HYPHEN) {
        return 1
    }

    let string_end = string+1 + string_length

    // Check for unrecognized characters
    for (let p = string+1; p < string_end; p=p+1) {
        let check_char = get(p)
        if (p == string+1) * (check_char == _HYPHEN) {
            // Skip if the first char is a hyphen
            continue
        }

        if (check_char < 48) + (check_char >= 58) {
            // Return error code for unrecognized character
            return 1
        }
    }

    // Construct the integer value
    let int_value = 0
    let factor = 1
    for (p = string_end-1; p > string; p=p-1) {
        let digit_char = get(p)
        if (digit_char == _HYPHEN) {
            break
        }

        let digit = digit_char - 48
        int_value = int_value + digit*factor
        factor = factor*10
    }

    // Apply negative
    let is_negative = first_char == _HYPHEN
    if is_negative {
        int_value = -int_value
    }

    set(p_dest, int_value)
    return 0
}


// Copy `n` slots from `src` to `dest`
fn memcpy(dest, src, n) {
    let src_end = src + n
    for (let p = src; p < src_end; p=p+1) {
        let value = get(p)
        set(dest, value)
        dest = dest + 1
    }
}


// Copy no more than `n` characters of `src` into `dest`.
fn strncpy(dest, src, n) {
    let src_length = get(src)
    let iterations = min(src_length, n)
    let src_end = src + 1 + iterations

    set(dest, src_length)
    dest = dest + 1

    for (let p = src + 1; p < src_end; p = p + 1) {
        let char = get(p)
        set(dest, char)
        dest = dest + 1
    }
}


// Concatenate no more than `n` characters of `s2` onto `s1`
fn strncat(s1, s2, n) {
    let s1_length = get(s1)
    let s2_length = get(s2)
    let chars_to_copy = min(s2_length, n)
    let new_length = s1_length + chars_to_copy
    set(s1, new_length)

    let s2_end = s2 + 1 + chars_to_copy
    let s1_ptr = s1 + 1 + s1_length
    for (let p = s2 + 1; p < s2_end; p = p + 1) {
        let char = get(p)
        set(s1_ptr, char)
        s1_ptr = s1_ptr + 1
    }
}


// Copy a substring of `src` into `dest`
fn substr(dest, src, start_index, end_index) {
    if start_index > end_index {
        return -1
    }

    let src_length = get(src)

    if start_index < 0 + end_index >= src_length {
        return -1
    }

    let substr_length = end_index - start_index + 1
    set(dest, substr_length)
    dest = dest + 1

    let substr_end = src + start_index
    for (let p = src+start_index; p < substr_end; p = p + 1) {
        let char = get(p)
        set(dest, char)
        dest = dest + 1
    }

    return 0
}


// Inserts `value` into a pattern string based on the first formatting code
// - %i -- Format integer
// - %s -- Format string
fn formatn(dest, max_length, pattern, value) {
    let temp_buffer[12]

    let scan_for_code = 0
    let code_seen = 0

    let dest_len = 0
    let p_dest = dest+1

    let pattern_end = pattern+1 + get(pattern)
    for (let p_pattern = pattern+1; p_pattern < pattern_end; p_pattern=p_pattern+1) {
        let char = get(p_pattern)

        if scan_for_code {
            scan_for_code = 0
            let copy_buffer = -1
            if char == _FORMAT_CODE_INT {
                code_seen = 1
                int_to_str(temp_buffer, value)
                copy_buffer = temp_buffer
            }
            else if char == _FORMAT_CODE_STRING {
                code_seen = 1
                copy_buffer = value
            }
            else {
                set(temp_buffer, 2)
                set(temp_buffer+1, _FORMAT_CODE_PREFIX)
                set(temp_buffer+2, char)
                copy_buffer = temp_buffer
            }
            
            // Copy chars from copy buffer into dest
            let buffer_end = copy_buffer+1 + get(copy_buffer)
            let length_overflow = 0
            for (let p_buf = copy_buffer+1; p_buf < buffer_end; p_buf=p_buf+1) {
                let buf_char = get(p_buf)
                set(p_dest, buf_char)
                p_dest = p_dest+1
                dest_len = dest_len+1
                length_overflow = dest_len >= max_length
                if length_overflow {
                    break
                }
            }
            
            if length_overflow {
                break
            }
        }
        else {
            if (char == _FORMAT_CODE_PREFIX) * !code_seen {
                scan_for_code = 1
            }
            else {
                set(p_dest, char)
                p_dest = p_dest+1
                dest_len = dest_len + 1
                if dest_len >= max_length {
                    break
                }
            }
        }
    }

    set(dest, dest_len)
    return dest_len >= max_length
}


fn format(dest, pattern, value) {
    return formatn(dest, MAX_INT, pattern, value)
}


fn str_equals(s1, s2) {
    let s1_length = get(s1)
    let s2_length = get(s2)
    if s1_length != s2_length {
        return 0
    }

    let p1 = s1+1
    let p2 = s2+1
    let p1_end = s1+1 + s1_length
    while (p1 < p1_end) {
        let char1 = get(p1)
        let char2 = get(p2)
        if char1 != char2 {
            return 0
        }

        p1 = p1+1
        p2 = p2+1
    }

    return 1
}


fn find_substr(string, substr) {
    let string_length = get(string)
    let substr_length = get(substr)
    if substr_length > string_length {
        return -1
    }

    let string_end = string+1 + string_length
    let substr_start = substr+1

    let string_index = 0
    let substr_index = 0

    for (let p = string; p < string_end; p=p+1) {
        let char = get(p)
        let subchar = get(substr_start+substr_index)
        if char == subchar {
            substr_index = substr_index+1
            if substr_index == substr_length {
                return string_index - substr_length
            }
        }
        else {
            substr_index = 0
        }
        string_index = string_index + 1
    }

    return -1
}