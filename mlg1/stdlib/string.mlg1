include "math"


define _FORMAT_CODE_PREFIX 37   // '%'
define _FORMAT_CODE_INT 105     // 'i'
define _FORMAT_CODE_STRING 115  // 's'


// Convert an integer to an ascii encoded string
fn int_to_str(buffer, x) {
    let amount_digits = x == 0
    let is_negative = x < 0
    x = abs(x)

    let x_copy = x
    while x_copy > 0 {
        x_copy = x_copy / 10
        amount_digits = amount_digits + 1
    }

    if is_negative {
        set(buffer, amount_digits+1)  // Set the length of the string
        buffer = buffer + 1
        set(buffer, 45)  // Set hyphen for negative
    }
    else {
        set(buffer, amount_digits)  // Set the length of the string
    }

    for (let i = buffer+amount_digits; i > buffer; i = i - 1) {
        let digit = x % 10 + 48
        x = x / 10
        set(i, digit)
    }
}


// Copy `n` slots from `src` to `dest`
fn memcpy(dest, src, n) {
    let src_end = src + n
    for (let p = src; p < src_end; p=p+1) {
        let value = get(p)
        set(dest, value)
        dest = dest + 1
    }
}


// Copy no more than `n` characters of `src` into `dest`.
fn strncpy(dest, src, n) {
    let src_length = get(src)
    let iterations = min(src_length, n)
    let src_end = src + 1 + iterations

    set(dest, src_length)
    dest = dest + 1

    for (let p = src + 1; p < src_end; p = p + 1) {
        let char = get(p)
        set(dest, char)
        dest = dest + 1
    }
}


// Concatenate no more than `n` characters of `s2` onto `s1`
fn strncat(s1, s2, n) {
    let s1_length = get(s1)
    let s2_length = get(s2)
    let chars_to_copy = min(s2_length, n)
    let new_length = s1_length + chars_to_copy
    set(s1, new_length)

    let s2_end = s2 + 1 + chars_to_copy
    let s1_ptr = s1 + 1 + s1_length
    for (let p = s2 + 1; p < s2_end; p = p + 1) {
        let char = get(p)
        set(s1_ptr, char)
        s1_ptr = s1_ptr + 1
    }
}


// Copy a substring of `src` into `dest`
fn substr(dest, src, start_index, end_index) {
    if start_index > end_index {
        return -1
    }

    let src_length = get(src)

    if start_index < 0 + end_index >= src_length {
        return -1
    }

    let substr_length = end_index - start_index + 1
    set(dest, substr_length)
    dest = dest + 1

    let substr_end = src + start_index
    for (let p = src+start_index; p < substr_end; p = p + 1) {
        let char = get(p)
        set(dest, char)
        dest = dest + 1
    }

    return 0
}


// Inserts `value` into a pattern string based on the first formatting code
// - %i -- Format integer
// - %s -- Format string
fn formatn(dest, max_length, pattern, value) {
    let temp_buffer[12]

    let scan_for_code = 0
    let code_seen = 0

    let dest_len = 0
    let p_dest = dest+1

    let pattern_end = pattern+1 + get(pattern)
    for (let p_pattern = pattern+1; p_pattern < pattern_end; p_pattern=p_pattern+1) {
        let char = get(p_pattern)

        if scan_for_code {
            scan_for_code = 0
            let copy_buffer = -1
            if char == _FORMAT_CODE_INT {
                code_seen = 1
                int_to_str(temp_buffer, value)
                copy_buffer = temp_buffer
            }
            else if char == _FORMAT_CODE_STRING {
                code_seen = 1
                copy_buffer = value
            }
            else {
                set(temp_buffer, 2)
                set(temp_buffer+1, _FORMAT_CODE_PREFIX)
                set(temp_buffer+2, char)
                copy_buffer = temp_buffer
            }
            
            // Copy chars from copy buffer into dest
            let buffer_end = copy_buffer+1 + get(copy_buffer)
            let length_overflow = 0
            for (let p_buf = copy_buffer+1; p_buf < buffer_end; p_buf=p_buf+1) {
                let buf_char = get(p_buf)
                set(p_dest, buf_char)
                p_dest = p_dest+1
                dest_len = dest_len+1
                length_overflow = dest_len >= max_length
                if length_overflow {
                    break
                }
            }
            
            if length_overflow {
                break
            }
        }
        else {
            if (char == _FORMAT_CODE_PREFIX) * !code_seen {
                scan_for_code = 1
            }
            else {
                set(p_dest, char)
                p_dest = p_dest+1
                dest_len = dest_len + 1
                if dest_len >= max_length {
                    break
                }
            }
        }
    }

    set(dest, dest_len)
    return dest_len >= max_length
}


fn format(dest, pattern, value) {
    return formatn(dest, MAX_INT, pattern, value)
}
